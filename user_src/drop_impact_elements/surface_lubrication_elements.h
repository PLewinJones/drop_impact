// Interface lubrication element. Unified problems
#ifndef OOMPH_INTERFACE_LUBRICATION_HEADER
#define OOMPH_INTERFACE_LUBRICATION_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// oomph-lib headers
#include "../fluid_interface/specific_node_update_interface_elements.h"

namespace oomph
{
  //==================================================================
  /// Generic vapour lubrication equations implemented
  /// independently of the dimension and then specialised using
  /// the generic mechanisms introduce in the FluidInterfaceElements
  //=================================================================
  class InterfaceLubricationElement : public FluidInterfaceElement
  {
  private:
    /// Pointer to ratio of vapour viscosity to liquid viscosity
    double* Vapour_Viscosity_Ratio_pt;

    /// Pointer to Dim-less Hamaker number
    double* Hamaker_pt;

    /// Pointer to Dim-less Mean Free Path
    double* Mean_Free_Path_pt;

    /// Pointer to Film Cutoff
    double* Film_Cutoff_pt;

    /// Pointer to Flag for Drop-Drop Simulation
    bool* Drop_Drop_Flag_pt;

    /// Pointer to GKE factor Delta Tau P function
    void (*GKE_Tau_P_fct_pt)(const double& Kn, double& result);

    /// Pointer to GKE factor Delta Tau C function
    void (*GKE_Tau_C_fct_pt)(const double& Kn, double& result);

    /// Pointer to GKE factor Delta Phi P function
    void (*GKE_Phi_P_fct_pt)(const double& Kn, double& result);

    /// Pointer to GKE factor Delta Phi C function
    void (*GKE_Phi_C_fct_pt)(const double& Kn, double& result);

  protected:
    /// Index at which the Vapour Pressure is stored at the
    /// nodes
    Vector<unsigned> Pv_index;

    /// Index at which the Arc length is stored at the
    /// nodes
    Vector<unsigned> Al_index;

    /// Default value of the physical constants
    static double Default_Physical_Constant_Value;

    /// Get the Vapour Pressure
    double interpolated_Pv(const Vector<double>& s);

    /// Get the arc length
    double interpolated_Al(const Vector<double>& s);

    /// Overload the Helper function to calculate the residuals and
    /// jacobian entries. This particular function ensures that the
    /// additional entries are calculated inside the integration loop
    void add_additional_residual_contributions_interface(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag,
      const Shape& psif,
      const DShape& dpsifds,
      const DShape& dpsifdS,
      const DShape& dpsifdS_div,
      const Vector<double>& s,
      const Vector<double>& interpolated_x,
      const Vector<double>& interpolated_n,
      const double& W,
      const double& J);

    /// Function to calculate GKE Tau P factor
    void get_GKE_Tau_P(const double& Kn, double& result)
    {
      // If the function pointer is zero return 1
      if (GKE_Tau_P_fct_pt == 0)
      {
        result = 1.0;
      }
      // Otherwise call the function
      else
      {
        (*GKE_Tau_P_fct_pt)(Kn, result);
      }
    }

    /// Function to calculate GKE Tau C factor
    void get_GKE_Tau_C(const double& Kn, double& result)
    {
      // If the function pointer is zero return 1
      if (GKE_Tau_C_fct_pt == 0)
      {
        result = 1.0;
      }
      // Otherwise call the function
      else
      {
        (*GKE_Tau_C_fct_pt)(Kn, result);
      }
    }

    /// Function to calculate GKE Phi P factor
    void get_GKE_Phi_P(const double& Kn, double& result)
    {
      // If the function pointer is zero return 1
      if (GKE_Phi_P_fct_pt == 0)
      {
        result = 1.0;
      }
      // Otherwise call the function
      else
      {
        (*GKE_Phi_P_fct_pt)(Kn, result);
      }
    }

    /// Function to calculate GKE Phi C factor
    void get_GKE_Phi_C(const double& Kn, double& result)
    {
      // If the function pointer is zero return 1
      if (GKE_Phi_C_fct_pt == 0)
      {
        result = 1.0;
      }
      // Otherwise call the function
      else
      {
        (*GKE_Phi_C_fct_pt)(Kn, result);
      }
    }


    /// Add the element's contribution to its residuals vector,
    /// jacobian matrix and mass matrix
    void fill_in_contribution_to_jacobian_and_mass_matrix(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix)
    {
      // Add the contribution to the jacobian
      this->fill_in_contribution_to_jacobian(residuals, jacobian);
      // No mass matrix terms, but should probably do kinematic bit here
    }

  public:
    /// Constructor that passes the bulk element and face index down
    /// to the underlying
    InterfaceLubricationElement() : FluidInterfaceElement()
    {
      // Initialise the values
      Vapour_Viscosity_Ratio_pt = &Default_Physical_Constant_Value;
      Hamaker_pt = &Default_Physical_Constant_Value;
      Mean_Free_Path_pt = &Default_Physical_Constant_Value;
      Film_Cutoff_pt=&Default_Physical_Constant_Value;
      Drop_Drop_Flag_pt = 0;

      GKE_Tau_P_fct_pt = 0;
      GKE_Tau_C_fct_pt = 0;
      GKE_Phi_P_fct_pt = 0;
      GKE_Phi_C_fct_pt = 0;
    }

    /// Destructor should not delete anything
    ~InterfaceLubricationElement() {}


    // Access function for the GKE Tau P factor pointer
    void (*&gke_Tau_P_fct_pt())(const double& Kn, double& result)
    {
      return GKE_Tau_P_fct_pt;
    }

    // Access function for the GKE Tau C factor pointer
    void (*&gke_Tau_C_fct_pt())(const double& Kn, double& result)
    {
      return GKE_Tau_C_fct_pt;
    }

    // Access function for the GKE Phi P factor pointer
    void (*&gke_Phi_P_fct_pt())(const double& Kn, double& result)
    {
      return GKE_Phi_P_fct_pt;
    }

    // Access function for the GKE Phi C factor pointer
    void (*&gke_Phi_C_fct_pt())(const double& Kn, double& result)
    {
      return GKE_Phi_C_fct_pt;
    }


    // Set the pv_index
    inline void set_pv_index(const Vector<unsigned>& pv_index)
    {
      this->Pv_index = pv_index;
    }

    // Set the al_index
    inline void set_al_index(const Vector<unsigned>& al_index)
    {
      this->Al_index = al_index;
    }

    /// Return the vapour viscosity ratio
    double vapour_viscosity_ratio()
    {
      return *Vapour_Viscosity_Ratio_pt;
    }

    /// Return the Dim-less Hamaker number
    double hamaker()
    {
      return *Hamaker_pt;
    }

    /// Return the Dim-less Mean Free Path
    double mean_free_path()
    {
      return *Mean_Free_Path_pt;
    }

    /// Return the Film Cutoff
    double film_cutoff()
    {
      return *Film_Cutoff_pt;
    }

    bool drop_drop_flag()
    {
      if (Drop_Drop_Flag_pt == 0)
      {
        return false;
      }
      else
      {
        return *Drop_Drop_Flag_pt;
      }
    }

    /// Access function for pointer to the vapour viscosity ratio
    double*& vapour_viscosity_ratio_pt()
    {
      return Vapour_Viscosity_Ratio_pt;
    }

    /// Access function for pointer to the Dim-less Hamaker number
    double*& hamaker_pt()
    {
      return Hamaker_pt;
    }

    /// Access function for pointer to the Dim-less mean free path
    double*& mean_free_path_pt()
    {
      return Mean_Free_Path_pt;
    }

    /// Access function for film cutoff
    double*& film_cutoff_pt()
    {
      return Film_Cutoff_pt;
    }

    bool*& drop_drop_flag_pt(){

      return Drop_Drop_Flag_pt;
    }

    // fix the vapour pressure
    void fix_vapour_pressure(const unsigned& pv_dof, const double& pv_value)
    {
      this->node_pt(pv_dof)->pin(this->Pv_index[pv_dof]);
      this->node_pt(pv_dof)->set_value(this->Pv_index[pv_dof], pv_value);
    }

    // fix the vapour pressure
    void unpin_vapour_pressure(const unsigned& pv_dof)
    {
      this->node_pt(pv_dof)->unpin(this->Pv_index[pv_dof]);
    }

    // set the vapour pressure (e.g for initial condition)
    void set_vapour_pressure(const unsigned& pv_dof, const double& pv_value)
    {
      this->node_pt(pv_dof)->set_value(this->Pv_index[pv_dof], pv_value);
    }

    // fix the arc length
    void fix_arc_length(const unsigned& al_dof, const double& al_value)
    {
      this->node_pt(al_dof)->pin(this->Al_index[al_dof]);
      this->node_pt(al_dof)->set_value(this->Al_index[al_dof], al_value);
    }

    /// Overload the output function in .cc file
    void output(std::ostream& outfile)
    {
      FiniteElement::output(outfile);
    }


    /// Overload the output function
    void output(std::ostream& outfile, const unsigned& n_plot);


    /// Overload the C-style output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// C-style Output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }

  }; // End of Vapour Class

  /// =============================================================================
  /// This is the policy class for the Interface Lubrication equations which
  /// require one additional value for the surface concentration
  //=============================================================================
  template<>
  class FluidInterfaceAdditionalValues<InterfaceLubricationElement>
  {
  public:
    FluidInterfaceAdditionalValues<InterfaceLubricationElement>() {}

    inline unsigned nadditional_values(const unsigned& n)
    {
      return 2;
    }

    inline void setup_equation_indices(
      InterfaceLubricationElement* const& element_pt, const unsigned& id)
    {
      const unsigned n_node = element_pt->nnode();
      Vector<unsigned> pv_index(n_node);
      Vector<unsigned> al_index(n_node);
      for (unsigned n = 0; n < n_node; n++)
      {
        pv_index[n] = dynamic_cast<BoundaryNodeBase*>(element_pt->node_pt(n))
                        ->index_of_first_value_assigned_by_face_element(id);
        al_index[n] = dynamic_cast<BoundaryNodeBase*>(element_pt->node_pt(n))
                        ->index_of_first_value_assigned_by_face_element(id) +
                      1;
      }

      element_pt->set_pv_index(pv_index);
      element_pt->set_al_index(al_index);
    }
  };

  /// Specialise to the Axisymmetric geometry
  template<class ELEMENT>
  class ElasticAxisymmetricInterfaceLubricationElement
    : public ElasticUpdateFluidInterfaceElement<InterfaceLubricationElement,
                                                AxisymmetricDerivatives,
                                                ELEMENT>
  {
  public:
    ElasticAxisymmetricInterfaceLubricationElement(
      FiniteElement* const& element_pt, const int& face_index)
      : ElasticUpdateFluidInterfaceElement<InterfaceLubricationElement,
                                           AxisymmetricDerivatives,
                                           ELEMENT>(element_pt, face_index)
    {
    }
  };


  // Define the bounding element type for the axisymmetric surface
  template<class ELEMENT>
  class BoundingElementType<
    ElasticUpdateFluidInterfaceElement<InterfaceLubricationElement,
                                       AxisymmetricDerivatives,
                                       ELEMENT>>
    : public ElasticPointFluidInterfaceBoundingElement<ELEMENT>
  {
  public:
    BoundingElementType<
      ElasticUpdateFluidInterfaceElement<InterfaceLubricationElement,
                                         AxisymmetricDerivatives,
                                         ELEMENT>>()
      : ElasticPointFluidInterfaceBoundingElement<ELEMENT>()
    {
    }
  };

} // namespace oomph

#endif
